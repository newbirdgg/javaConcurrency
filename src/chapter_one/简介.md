# 第一章 简 介

* 要想充分发挥多处理器系统的强大计算力，最简单的方式就是使用线程。

## 1.1 并发简史

* 操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为每个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书。在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量、以及文件等。
* 之所以在计算机中加入操作系统来实现多个程序的同时执行，主要原因是：
  - **资源利用率**：如果在等待的同时可以运行另一个程序，那么无疑将提高资源的利用率。
  - **公平性**：不同的用户和程序对于计算机上的资源有这同等的使用权。
  - **便利性**：在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要的时候相互通信。
* 这些促使进程出现的因素（资源利用率、公平性以及便利性）同样也促使着线程的出现。线程允许在同一个进程中同时存在多个程序控制流。线程会共享进程范围内的资源，每个线程都有各自的程序计数器、栈以及局部变量。
* 线程也被称为轻量级进程。同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。

## 1.2 线程的优势

- 线程能够将大部分的异步工作流转换成串行的工作流，因此能更好地模拟人类的工作方式和交互方式。
- 线程还可以简化JVM的实现，垃圾收集器通常在一个或者多个专门的线程中进行。

#### 1.2.1 发挥多处理器的强大功能

* CPU的基本调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理器上运行。
* 多线程程序可以同时在多个处理器上执行，多线程程序可以通过提高处理器资源的利用率来提升系统吞吐率。
* 在多线程中如果一个线程在等待I/O操作完成，另一线程可以继续运行，使程序能够在I/O阻塞期间继续运行。

#### 1.2.2 建模的简单性
* 通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个单独的线程中，并在特定的同步位置进行交互。

#### 1.2.3 异步事件的简化处理

* 服务器应用程序在接受来自多个远程客户端的套接字连接请求时，如果为每个连接都分配其各自的线程并且使用同步I/O，那么就会降低这类程序的开发难度。

## 1.3 线程带来的风险

#### 1.3.1安全性问题

* 线程安全性可能是非常复杂的，在没有充足同步的情况下，多线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。

**程序清单 1-1 非线程安全的数值序列生成器（不建议这么写）**

```java
@NotThreadSafe
public class UnsafeSequence{
    private int value;
    
    /** 返回一个唯一的数值 */
    public int getNext(){
        return value++;
    }
}
```

* **UnsafeSequence**的问题在于,如果执行时机不对，那么两个线程在调用**getNext**时会得到相同的值。虽然递增运算value++看上去是单个操作，但是事实上它包含了三个独立的操作：**读取value，将value加1，并且将计算结果写入value** 。运行时可能将多个线程之间的操作交替执行因此这两个线程可能同时执行读操作，从而使得他们得到相同的值，并都将这个值加1。结果就是，在不同的线程的调用中返回了相同的数值。
* 如果用**@TreadSafe**来标注某个类，那么开发人员可以放心地在多线程环境下使用这个类，维护人员也会发现他能保证线程安全性
* 在**UnsafeSequence**类中说明的是一种常见的并发安全问题，称为**竞态条件**
* 由于多个线程要共享相同的内存地址空间，并且是并发运行，因此他们可能会访问或者修改其他线程正在使用的变量，当然也是存在着它的**便利**和**风险**
  - **便利**：因为这种方式比其他线程间通信机制更容易实现数据共享
  - **风险**：线程会由于无法预料的数据变化而发生错误

* 通过将**getNext**修改为一个同步方法，可以修复**UnsafeSequence**中的错误

**程序清单 1-2 线程安全的数值序列生成器**

```java
@TreadSafe
public class Sequence{
    @GuardedBy("this") private int value;
    
    public synchronized int getNext(){
        return value++;
    }
}
```

#### 1.3.2 活跃性问题

* 当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。线程将带来其他一些活跃性问题。例如：如果线程A在等待线程B释放其持有的资源，而线程B永远都不释放该资源，那么A就会永久的等待下去。

#### 1.3.3 性能问题

* 多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁出现切换上下文操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，并且CPU时间将更多的花在线程调度而不是线程运行上。
* 当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。





